# Migration Guide: ignite-element v2 (Ignite JSX & Renderer Strategies)

ignite-element v2 introduces the Ignite JSX runtime as the default renderer, a renderer strategy abstraction, and a central configuration file (`ignite.config.ts`) that controls global styles and renderer selection. This guide walks you through the upgrade from v1.x.

## TL;DR

1. **Update dependencies** – install the latest `ignite-element` and ensure your state-library peers (XState, Redux Toolkit, MobX) remain pinned.
2. **Configure TypeScript/JSX** – set `jsxImportSource` to `ignite-element/jsx` so JSX compiles against the Ignite runtime.
3. **Add `ignite.config.ts`** – declare `defineIgniteConfig({ renderer: "ignite-jsx", globalStyles: ... })` and ensure the file is imported once (or rely on the Vite/Webpack plugins).
4. **Switch renderers** – author JSX directly (recommended) or opt back into the lit strategy by setting `renderer: "lit"`.
5. **Verify lifecycle** – shared adapters are reference-counted: they stop automatically when the last element disconnects (configurable if you prefer manual shutdown).

## 1. Upgrade ignite-element

```bash
pnpm add ignite-element@next
# or npm/yarn equivalent
```

Ignite JSX ships with no additional peer dependencies. If you still rely on lit templates, keep `lit-html` installed as before.

## 2. Configure TypeScript for Ignite JSX

Set the JSX runtime for your project. You can use a file-level pragma (`/** @jsxImportSource ignite-element/jsx */`) or configure it globally:

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "ignite-element/jsx"
  }
}
```

This enables TypeScript (and most bundlers) to compile JSX using the Ignite runtime helpers (`jsx`, `jsxs`, `jsxDEV`).

## 3. Add `ignite.config.ts`

Centralise styling defaults and renderer choice via the new config file:

```ts
// ignite.config.ts
import { defineIgniteConfig } from "ignite-element";

export default defineIgniteConfig({
  renderer: "ignite-jsx", // omit or set to "lit" to opt into the lit strategy
  globalStyles: new URL("./styles.css", import.meta.url).href,
});
```

Import this once in your app entry point. If you use Vite or Webpack, the provided plugins (`igniteConfigVitePlugin`, `IgniteConfigWebpackPlugin`) automatically inject the config when it exists.

## 4. Update Renderers

- **Ignite JSX (default)** – author JSX directly in `component(tag, renderer)` calls. The facade callbacks (`states`, `commands`) remain unchanged.
- **lit strategy (optional)** – keep existing lit templates by setting `renderer: "lit"` in `ignite.config.ts`. No runtime code changes are required.

Example JSX component:

```tsx
/** @jsxImportSource ignite-element/jsx */

const component = igniteCore({
  source: toggleMachine,
  states: (snapshot) => ({ isOn: snapshot.matches("on") }),
  commands: (actor) => ({ toggle: () => actor.send({ type: "TOGGLE" }) }),
});

component("toggle-button", ({ isOn, toggle }) => (
  <button onClick={toggle}>{isOn ? "On" : "Off"}</button>
));
```

## 5. Styling

Global styles now flow through `defineIgniteConfig`. Per-component styling works the same way in both Ignite JSX and lit strategies (inline styles, `<style>` nodes, etc.).

## 6. Lifecycle Notes

- Isolated adapters are stopped automatically on disconnect (unchanged).
- Shared adapters (long-lived instances you provide) are now reference-counted. Ignite stops the shared adapter once the final element using it disconnects. If you need full manual control, pass `cleanup: false` to `igniteCore`/`createComponentFactory`.

```ts
const actor = createActor(machine);
actor.start();

const shared = igniteCore({ source: actor, states: /* ... */ });
shared("shared-counter", Renderer);

// Optional escape hatch: manage lifecycle manually
const manual = igniteCore({
  source: actor,
  cleanup: false,
  states: /* ... */
});

manual("manual-counter", Renderer);

// Later, when the host app shuts down
actor.stop();
```

## 7. Additional Tips

- Type inference requires no extra helpers: inline your `states`/`commands` callbacks or reuse types from your state library (`InferStateAndEvent`, XState machine types, etc.).
- If you need per-component renderer overrides, continue supplying `createRenderStrategy` when calling `igniteElementFactory`.
- Watch the changelog for follow-up improvements (lit strategy enhancements, devtooling).

## Checklist

- [ ] Upgraded to ignite-element v2
- [ ] Updated `tsconfig.json` (or file pragmas) for Ignite JSX
- [ ] Added/imported `ignite.config.ts`
- [ ] Verified components render with JSX (or opted into lit)
- [ ] Confirmed shared adapter lifecycle behaviour (auto-stop or manual opt-out)

Need help? Open a discussion or issue on GitHub—we’d love feedback as you adopt the Ignite JSX runtime.
